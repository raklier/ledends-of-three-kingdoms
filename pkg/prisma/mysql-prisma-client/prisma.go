
    // Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
  "errors"

  "os"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
    return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
  Endpoint  string
  Secret    string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
  endpoint := DefaultEndpoint
  secret   := Secret
	if options != nil {
    endpoint = options.Endpoint
    secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}


var DefaultEndpoint = os.Getenv("LTK_MYSQL_PRISMA_ENDPOINT")
var Secret          = ""


      func (client *Client) Test (params TestWhereUniqueInput) *TestExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"TestWhereUniqueInput!", "Test"},
          "test",
          []string{"id","test"})

        return &TestExec{ret}
      }

      type TestsParams struct {
        Where *TestWhereInput `json:"where,omitempty"`
OrderBy *TestOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) Tests (params *TestsParams) *TestExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"TestWhereInput", "TestOrderByInput", "Test"},
          "tests",
          []string{"id","test"})

        return &TestExecArray{ret}
      }

      type TestsConnectionParams struct {
        Where *TestWhereInput `json:"where,omitempty"`
OrderBy *TestOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) TestsConnection (params *TestsConnectionParams) (*TestConnectionExec) {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where:   params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip:    params.Skip,
            After:   params.After,
            Before:  params.Before,
            First:   params.First,
            Last:    params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"TestWhereInput", "TestOrderByInput", "Test"},
          "testsConnection",
          []string{"edges", "pageInfo"})

        return &TestConnectionExec{ret}
      }



      func (client *Client) CreateTest (params TestCreateInput) *TestExec {
        ret := client.Client.Create(
          params,
          [2]string{"TestCreateInput!", "Test"},
          "createTest",
          []string{"id","test"})

        return &TestExec{ret}
      }

      type TestUpdateParams struct {
        Data TestUpdateInput `json:"data"`
Where TestWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateTest (params TestUpdateParams) *TestExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"TestUpdateInput!", "TestWhereUniqueInput!", "Test"},
                 "updateTest",
                 []string{"id","test"})

        return &TestExec{ret}
      }

      type TestUpdateManyParams struct {
        Data TestUpdateManyMutationInput `json:"data"`
Where *TestWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyTests (params TestUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"TestUpdateManyMutationInput!", "TestWhereInput"},
          "updateManyTests")
        return &BatchPayloadExec{exec}
      }

      type TestUpsertParams struct {
        Where TestWhereUniqueInput `json:"where"`
Create TestCreateInput `json:"create"`
Update TestUpdateInput `json:"update"`
      }
      func (client *Client) UpsertTest (params TestUpsertParams) *TestExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"TestWhereUniqueInput!", "TestCreateInput!", "TestUpdateInput!","Test"},
          "upsertTest",
          []string{"id","test"})

        return &TestExec{ret}
      }

      func (client *Client) DeleteTest (params TestWhereUniqueInput) *TestExec {
        ret := client.Client.Delete(
          params,
          [2]string{"TestWhereUniqueInput!", "Test"},
          "deleteTest",
          []string{"id","test"})

        return &TestExec{ret}
      }

      func (client *Client) DeleteManyTests (params *TestWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "TestWhereInput", "deleteManyTests")
        return &BatchPayloadExec{exec}
      }


        type TestOrderByInput string
        const (
          TestOrderByInputIDAsc TestOrderByInput = "id_ASC"
TestOrderByInputIDDesc TestOrderByInput = "id_DESC"
TestOrderByInputTestAsc TestOrderByInput = "test_ASC"
TestOrderByInputTestDesc TestOrderByInput = "test_DESC"
          )

        type MutationType string
        const (
          MutationTypeCreated MutationType = "CREATED"
MutationTypeUpdated MutationType = "UPDATED"
MutationTypeDeleted MutationType = "DELETED"
          )

      type TestCreateInput struct {
        ID *string `json:"id,omitempty"`
Test *string `json:"test,omitempty"`
          }

      type TestUpdateInput struct {
        Test *string `json:"test,omitempty"`
          }

      type TestUpdateManyMutationInput struct {
        Test *string `json:"test,omitempty"`
          }

      type TestWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
Test *string `json:"test,omitempty"`
TestNot *string `json:"test_not,omitempty"`
TestIn []string `json:"test_in,omitempty"`
TestNotIn []string `json:"test_not_in,omitempty"`
TestLt *string `json:"test_lt,omitempty"`
TestLte *string `json:"test_lte,omitempty"`
TestGt *string `json:"test_gt,omitempty"`
TestGte *string `json:"test_gte,omitempty"`
TestContains *string `json:"test_contains,omitempty"`
TestNotContains *string `json:"test_not_contains,omitempty"`
TestStartsWith *string `json:"test_starts_with,omitempty"`
TestNotStartsWith *string `json:"test_not_starts_with,omitempty"`
TestEndsWith *string `json:"test_ends_with,omitempty"`
TestNotEndsWith *string `json:"test_not_ends_with,omitempty"`
And []TestWhereInput `json:"AND,omitempty"`
Or []TestWhereInput `json:"OR,omitempty"`
Not []TestWhereInput `json:"NOT,omitempty"`
          }

      type TestSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *TestWhereInput `json:"node,omitempty"`
And []TestSubscriptionWhereInput `json:"AND,omitempty"`
Or []TestSubscriptionWhereInput `json:"OR,omitempty"`
Not []TestSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type TestWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }




        type TestPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance TestPreviousValuesExec) Exec(ctx context.Context) (*TestPreviousValues, error) {
            var v TestPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance TestPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type TestPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance TestPreviousValuesExecArray) Exec(ctx context.Context) ([]TestPreviousValues, error) {
            var v []TestPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type TestPreviousValues struct {
          ID string `json:"id"`
Test *string `json:"test,omitempty"`
        }

        type TestEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *TestEdgeExec) Node() *TestExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Test"},
                    "node",
                    []string{"id","test"})

                  return &TestExec{ret}
                }

          func (instance TestEdgeExec) Exec(ctx context.Context) (*TestEdge, error) {
            var v TestEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance TestEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type TestEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance TestEdgeExecArray) Exec(ctx context.Context) ([]TestEdge, error) {
            var v []TestEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type TestEdge struct {
          Node Test `json:"node"`
Cursor string `json:"cursor"`
        }

        type TestSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *TestSubscriptionPayloadExec) Node() *TestExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Test"},
                    "node",
                    []string{"id","test"})

                  return &TestExec{ret}
                }

                func (instance *TestSubscriptionPayloadExec) PreviousValues() *TestPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "TestPreviousValues"},
                    "previousValues",
                    []string{"id","test"})

                  return &TestPreviousValuesExec{ret}
                }

          func (instance TestSubscriptionPayloadExec) Exec(ctx context.Context) (*TestSubscriptionPayload, error) {
            var v TestSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance TestSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type TestSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance TestSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TestSubscriptionPayload, error) {
            var v []TestSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type TestSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
Node *Test `json:"node,omitempty"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type TestExec struct {
          exec *prisma.Exec
        }

        

          func (instance TestExec) Exec(ctx context.Context) (*Test, error) {
            var v Test
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance TestExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type TestExecArray struct {
            exec *prisma.Exec
          }

          func (instance TestExecArray) Exec(ctx context.Context) ([]Test, error) {
            var v []Test
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type Test struct {
          ID string `json:"id"`
Test *string `json:"test,omitempty"`
        }

        type TestConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *TestConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                  func (instance *TestConnectionExec) Edges() *TestEdgeExecArray {
                    edges := instance.exec.Client.GetMany(
                      instance.exec,
                      nil,
                      [3]string{"TestWhereInput", "TestOrderByInput", "TestEdge"},
                      "edges",
                      []string{"cursor"})

                    nodes := edges.Client.GetMany(
                      edges,
                      nil,
                      [3]string{"", "", "Test"},
                      "node",
                      []string{"id", "createdAt", "updatedAt", "name", "desc"})

                    return &TestEdgeExecArray{nodes}
                  }

                  func (instance *TestConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateTest"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return &v, err
                  }

          func (instance TestConnectionExec) Exec(ctx context.Context) (*TestConnection, error) {
            var v TestConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance TestConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type TestConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance TestConnectionExecArray) Exec(ctx context.Context) ([]TestConnection, error) {
            var v []TestConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type TestConnection struct {
          PageInfo PageInfo `json:"pageInfo"`
Edges []TestEdge `json:"edges"`
        }

        type PageInfoExec struct {
          exec *prisma.Exec
        }

        

          func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
            var v PageInfo
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PageInfoExecArray struct {
            exec *prisma.Exec
          }

          func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
            var v []PageInfo
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type PageInfo struct {
          HasNextPage bool `json:"hasNextPage"`
HasPreviousPage bool `json:"hasPreviousPage"`
StartCursor *string `json:"startCursor,omitempty"`
EndCursor *string `json:"endCursor,omitempty"`
        }





        