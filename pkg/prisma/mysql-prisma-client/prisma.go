
    // Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
  "errors"

  "os"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
    return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
  Endpoint  string
  Secret    string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
  endpoint := DefaultEndpoint
  secret   := Secret
	if options != nil {
    endpoint = options.Endpoint
    secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}


var DefaultEndpoint = os.Getenv("LTK_MYSQL_PRISMA_ENDPOINT")
var Secret          = ""


      func (client *Client) Room (params RoomWhereUniqueInput) *RoomExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"RoomWhereUniqueInput!", "Room"},
          "room",
          []string{"id","createdAt","roomNickName"})

        return &RoomExec{ret}
      }

      type RoomsParams struct {
        Where *RoomWhereInput `json:"where,omitempty"`
OrderBy *RoomOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) Rooms (params *RoomsParams) *RoomExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"RoomWhereInput", "RoomOrderByInput", "Room"},
          "rooms",
          []string{"id","createdAt","roomNickName"})

        return &RoomExecArray{ret}
      }

      type RoomsConnectionParams struct {
        Where *RoomWhereInput `json:"where,omitempty"`
OrderBy *RoomOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) RoomsConnection (params *RoomsConnectionParams) (*RoomConnectionExec) {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where:   params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip:    params.Skip,
            After:   params.After,
            Before:  params.Before,
            First:   params.First,
            Last:    params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"RoomWhereInput", "RoomOrderByInput", "Room"},
          "roomsConnection",
          []string{"edges", "pageInfo"})

        return &RoomConnectionExec{ret}
      }

      func (client *Client) User (params UserWhereUniqueInput) *UserExec {
        ret := client.Client.GetOne(
          nil,
          params,
          [2]string{"UserWhereUniqueInput!", "User"},
          "user",
          []string{"id","nickName","password","loginAt","isInGame","token"})

        return &UserExec{ret}
      }

      type UsersParams struct {
        Where *UserWhereInput `json:"where,omitempty"`
OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) Users (params *UsersParams) *UserExecArray {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where: params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip: params.Skip,
            After: params.After,
            Before: params.Before,
            First: params.First,
            Last: params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"UserWhereInput", "UserOrderByInput", "User"},
          "users",
          []string{"id","nickName","password","loginAt","isInGame","token"})

        return &UserExecArray{ret}
      }

      type UsersConnectionParams struct {
        Where *UserWhereInput `json:"where,omitempty"`
OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
Skip *int32 `json:"skip,omitempty"`
After *string `json:"after,omitempty"`
Before *string `json:"before,omitempty"`
First *int32 `json:"first,omitempty"`
Last *int32 `json:"last,omitempty"`
      }
      func (client *Client) UsersConnection (params *UsersConnectionParams) (*UserConnectionExec) {
        var wparams *prisma.WhereParams
        if params != nil {
          wparams = &prisma.WhereParams{
            Where:   params.Where,
            OrderBy: (*string)(params.OrderBy),
            Skip:    params.Skip,
            After:   params.After,
            Before:  params.Before,
            First:   params.First,
            Last:    params.Last,
          }
        }

        ret := client.Client.GetMany(
          nil,
          wparams,
          [3]string{"UserWhereInput", "UserOrderByInput", "User"},
          "usersConnection",
          []string{"edges", "pageInfo"})

        return &UserConnectionExec{ret}
      }



      func (client *Client) CreateRoom (params RoomCreateInput) *RoomExec {
        ret := client.Client.Create(
          params,
          [2]string{"RoomCreateInput!", "Room"},
          "createRoom",
          []string{"id","createdAt","roomNickName"})

        return &RoomExec{ret}
      }

      type RoomUpdateParams struct {
        Data RoomUpdateInput `json:"data"`
Where RoomWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateRoom (params RoomUpdateParams) *RoomExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"RoomUpdateInput!", "RoomWhereUniqueInput!", "Room"},
                 "updateRoom",
                 []string{"id","createdAt","roomNickName"})

        return &RoomExec{ret}
      }

      type RoomUpdateManyParams struct {
        Data RoomUpdateManyMutationInput `json:"data"`
Where *RoomWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyRooms (params RoomUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"RoomUpdateManyMutationInput!", "RoomWhereInput"},
          "updateManyRooms")
        return &BatchPayloadExec{exec}
      }

      type RoomUpsertParams struct {
        Where RoomWhereUniqueInput `json:"where"`
Create RoomCreateInput `json:"create"`
Update RoomUpdateInput `json:"update"`
      }
      func (client *Client) UpsertRoom (params RoomUpsertParams) *RoomExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"RoomWhereUniqueInput!", "RoomCreateInput!", "RoomUpdateInput!","Room"},
          "upsertRoom",
          []string{"id","createdAt","roomNickName"})

        return &RoomExec{ret}
      }

      func (client *Client) DeleteRoom (params RoomWhereUniqueInput) *RoomExec {
        ret := client.Client.Delete(
          params,
          [2]string{"RoomWhereUniqueInput!", "Room"},
          "deleteRoom",
          []string{"id","createdAt","roomNickName"})

        return &RoomExec{ret}
      }

      func (client *Client) DeleteManyRooms (params *RoomWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "RoomWhereInput", "deleteManyRooms")
        return &BatchPayloadExec{exec}
      }

      func (client *Client) CreateUser (params UserCreateInput) *UserExec {
        ret := client.Client.Create(
          params,
          [2]string{"UserCreateInput!", "User"},
          "createUser",
          []string{"id","nickName","password","loginAt","isInGame","token"})

        return &UserExec{ret}
      }

      type UserUpdateParams struct {
        Data UserUpdateInput `json:"data"`
Where UserWhereUniqueInput `json:"where"`
      }
      func (client *Client) UpdateUser (params UserUpdateParams) *UserExec {
        ret := client.Client.Update(
                 prisma.UpdateParams{
                   Data: params.Data,
                   Where: params.Where,
                 },
                 [3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
                 "updateUser",
                 []string{"id","nickName","password","loginAt","isInGame","token"})

        return &UserExec{ret}
      }

      type UserUpdateManyParams struct {
        Data UserUpdateManyMutationInput `json:"data"`
Where *UserWhereInput `json:"where,omitempty"`
      }
      func (client *Client) UpdateManyUsers (params UserUpdateManyParams) *BatchPayloadExec {
        exec := client.Client.UpdateMany(
          prisma.UpdateParams{
            Data: params.Data,
            Where: params.Where,
          },
          [2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
          "updateManyUsers")
        return &BatchPayloadExec{exec}
      }

      type UserUpsertParams struct {
        Where UserWhereUniqueInput `json:"where"`
Create UserCreateInput `json:"create"`
Update UserUpdateInput `json:"update"`
      }
      func (client *Client) UpsertUser (params UserUpsertParams) *UserExec {
        uparams := &prisma.UpsertParams{
          Where:  params.Where,
          Create: params.Create,
          Update: params.Update,
        }
        ret := client.Client.Upsert(
          uparams,
          [4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!","User"},
          "upsertUser",
          []string{"id","nickName","password","loginAt","isInGame","token"})

        return &UserExec{ret}
      }

      func (client *Client) DeleteUser (params UserWhereUniqueInput) *UserExec {
        ret := client.Client.Delete(
          params,
          [2]string{"UserWhereUniqueInput!", "User"},
          "deleteUser",
          []string{"id","nickName","password","loginAt","isInGame","token"})

        return &UserExec{ret}
      }

      func (client *Client) DeleteManyUsers (params *UserWhereInput) *BatchPayloadExec {
        exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
        return &BatchPayloadExec{exec}
      }


        type UserOrderByInput string
        const (
          UserOrderByInputIDAsc UserOrderByInput = "id_ASC"
UserOrderByInputIDDesc UserOrderByInput = "id_DESC"
UserOrderByInputNickNameAsc UserOrderByInput = "nickName_ASC"
UserOrderByInputNickNameDesc UserOrderByInput = "nickName_DESC"
UserOrderByInputPasswordAsc UserOrderByInput = "password_ASC"
UserOrderByInputPasswordDesc UserOrderByInput = "password_DESC"
UserOrderByInputLoginAtAsc UserOrderByInput = "loginAt_ASC"
UserOrderByInputLoginAtDesc UserOrderByInput = "loginAt_DESC"
UserOrderByInputIsInGameAsc UserOrderByInput = "isInGame_ASC"
UserOrderByInputIsInGameDesc UserOrderByInput = "isInGame_DESC"
UserOrderByInputTokenAsc UserOrderByInput = "token_ASC"
UserOrderByInputTokenDesc UserOrderByInput = "token_DESC"
          )

        type RoomOrderByInput string
        const (
          RoomOrderByInputIDAsc RoomOrderByInput = "id_ASC"
RoomOrderByInputIDDesc RoomOrderByInput = "id_DESC"
RoomOrderByInputCreatedAtAsc RoomOrderByInput = "createdAt_ASC"
RoomOrderByInputCreatedAtDesc RoomOrderByInput = "createdAt_DESC"
RoomOrderByInputRoomNickNameAsc RoomOrderByInput = "roomNickName_ASC"
RoomOrderByInputRoomNickNameDesc RoomOrderByInput = "roomNickName_DESC"
          )

        type MutationType string
        const (
          MutationTypeCreated MutationType = "CREATED"
MutationTypeUpdated MutationType = "UPDATED"
MutationTypeDeleted MutationType = "DELETED"
          )

      type UserUpdateManyWithoutRoomInput struct {
        Create []UserCreateWithoutRoomInput `json:"create,omitempty"`
Delete []UserWhereUniqueInput `json:"delete,omitempty"`
Connect []UserWhereUniqueInput `json:"connect,omitempty"`
Set []UserWhereUniqueInput `json:"set,omitempty"`
Disconnect []UserWhereUniqueInput `json:"disconnect,omitempty"`
Update []UserUpdateWithWhereUniqueWithoutRoomInput `json:"update,omitempty"`
Upsert []UserUpsertWithWhereUniqueWithoutRoomInput `json:"upsert,omitempty"`
DeleteMany []UserScalarWhereInput `json:"deleteMany,omitempty"`
UpdateMany []UserUpdateManyWithWhereNestedInput `json:"updateMany,omitempty"`
          }

      type RoomWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
          }

      type UserUpdateWithoutRoomDataInput struct {
        NickName *string `json:"nickName,omitempty"`
Password *string `json:"password,omitempty"`
LoginAt *string `json:"loginAt,omitempty"`
IsInGame *bool `json:"isInGame,omitempty"`
Token *string `json:"token,omitempty"`
          }

      type UserWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
NickName *string `json:"nickName,omitempty"`
NickNameNot *string `json:"nickName_not,omitempty"`
NickNameIn []string `json:"nickName_in,omitempty"`
NickNameNotIn []string `json:"nickName_not_in,omitempty"`
NickNameLt *string `json:"nickName_lt,omitempty"`
NickNameLte *string `json:"nickName_lte,omitempty"`
NickNameGt *string `json:"nickName_gt,omitempty"`
NickNameGte *string `json:"nickName_gte,omitempty"`
NickNameContains *string `json:"nickName_contains,omitempty"`
NickNameNotContains *string `json:"nickName_not_contains,omitempty"`
NickNameStartsWith *string `json:"nickName_starts_with,omitempty"`
NickNameNotStartsWith *string `json:"nickName_not_starts_with,omitempty"`
NickNameEndsWith *string `json:"nickName_ends_with,omitempty"`
NickNameNotEndsWith *string `json:"nickName_not_ends_with,omitempty"`
Password *string `json:"password,omitempty"`
PasswordNot *string `json:"password_not,omitempty"`
PasswordIn []string `json:"password_in,omitempty"`
PasswordNotIn []string `json:"password_not_in,omitempty"`
PasswordLt *string `json:"password_lt,omitempty"`
PasswordLte *string `json:"password_lte,omitempty"`
PasswordGt *string `json:"password_gt,omitempty"`
PasswordGte *string `json:"password_gte,omitempty"`
PasswordContains *string `json:"password_contains,omitempty"`
PasswordNotContains *string `json:"password_not_contains,omitempty"`
PasswordStartsWith *string `json:"password_starts_with,omitempty"`
PasswordNotStartsWith *string `json:"password_not_starts_with,omitempty"`
PasswordEndsWith *string `json:"password_ends_with,omitempty"`
PasswordNotEndsWith *string `json:"password_not_ends_with,omitempty"`
LoginAt *string `json:"loginAt,omitempty"`
LoginAtNot *string `json:"loginAt_not,omitempty"`
LoginAtIn []string `json:"loginAt_in,omitempty"`
LoginAtNotIn []string `json:"loginAt_not_in,omitempty"`
LoginAtLt *string `json:"loginAt_lt,omitempty"`
LoginAtLte *string `json:"loginAt_lte,omitempty"`
LoginAtGt *string `json:"loginAt_gt,omitempty"`
LoginAtGte *string `json:"loginAt_gte,omitempty"`
IsInGame *bool `json:"isInGame,omitempty"`
IsInGameNot *bool `json:"isInGame_not,omitempty"`
Token *string `json:"token,omitempty"`
TokenNot *string `json:"token_not,omitempty"`
TokenIn []string `json:"token_in,omitempty"`
TokenNotIn []string `json:"token_not_in,omitempty"`
TokenLt *string `json:"token_lt,omitempty"`
TokenLte *string `json:"token_lte,omitempty"`
TokenGt *string `json:"token_gt,omitempty"`
TokenGte *string `json:"token_gte,omitempty"`
TokenContains *string `json:"token_contains,omitempty"`
TokenNotContains *string `json:"token_not_contains,omitempty"`
TokenStartsWith *string `json:"token_starts_with,omitempty"`
TokenNotStartsWith *string `json:"token_not_starts_with,omitempty"`
TokenEndsWith *string `json:"token_ends_with,omitempty"`
TokenNotEndsWith *string `json:"token_not_ends_with,omitempty"`
Room *RoomWhereInput `json:"room,omitempty"`
And []UserWhereInput `json:"AND,omitempty"`
Or []UserWhereInput `json:"OR,omitempty"`
Not []UserWhereInput `json:"NOT,omitempty"`
          }

      type UserUpsertWithWhereUniqueWithoutRoomInput struct {
        Where UserWhereUniqueInput `json:"where"`
Update UserUpdateWithoutRoomDataInput `json:"update"`
Create UserCreateWithoutRoomInput `json:"create"`
          }

      type RoomWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
CreatedAt *string `json:"createdAt,omitempty"`
CreatedAtNot *string `json:"createdAt_not,omitempty"`
CreatedAtIn []string `json:"createdAt_in,omitempty"`
CreatedAtNotIn []string `json:"createdAt_not_in,omitempty"`
CreatedAtLt *string `json:"createdAt_lt,omitempty"`
CreatedAtLte *string `json:"createdAt_lte,omitempty"`
CreatedAtGt *string `json:"createdAt_gt,omitempty"`
CreatedAtGte *string `json:"createdAt_gte,omitempty"`
RoomNickName *string `json:"roomNickName,omitempty"`
RoomNickNameNot *string `json:"roomNickName_not,omitempty"`
RoomNickNameIn []string `json:"roomNickName_in,omitempty"`
RoomNickNameNotIn []string `json:"roomNickName_not_in,omitempty"`
RoomNickNameLt *string `json:"roomNickName_lt,omitempty"`
RoomNickNameLte *string `json:"roomNickName_lte,omitempty"`
RoomNickNameGt *string `json:"roomNickName_gt,omitempty"`
RoomNickNameGte *string `json:"roomNickName_gte,omitempty"`
RoomNickNameContains *string `json:"roomNickName_contains,omitempty"`
RoomNickNameNotContains *string `json:"roomNickName_not_contains,omitempty"`
RoomNickNameStartsWith *string `json:"roomNickName_starts_with,omitempty"`
RoomNickNameNotStartsWith *string `json:"roomNickName_not_starts_with,omitempty"`
RoomNickNameEndsWith *string `json:"roomNickName_ends_with,omitempty"`
RoomNickNameNotEndsWith *string `json:"roomNickName_not_ends_with,omitempty"`
PlayersEvery *UserWhereInput `json:"players_every,omitempty"`
PlayersSome *UserWhereInput `json:"players_some,omitempty"`
PlayersNone *UserWhereInput `json:"players_none,omitempty"`
And []RoomWhereInput `json:"AND,omitempty"`
Or []RoomWhereInput `json:"OR,omitempty"`
Not []RoomWhereInput `json:"NOT,omitempty"`
          }

      type UserUpdateManyWithWhereNestedInput struct {
        Where UserScalarWhereInput `json:"where"`
Data UserUpdateManyDataInput `json:"data"`
          }

      type UserScalarWhereInput struct {
        ID *string `json:"id,omitempty"`
IDNot *string `json:"id_not,omitempty"`
IDIn []string `json:"id_in,omitempty"`
IDNotIn []string `json:"id_not_in,omitempty"`
IDLt *string `json:"id_lt,omitempty"`
IDLte *string `json:"id_lte,omitempty"`
IDGt *string `json:"id_gt,omitempty"`
IDGte *string `json:"id_gte,omitempty"`
IDContains *string `json:"id_contains,omitempty"`
IDNotContains *string `json:"id_not_contains,omitempty"`
IDStartsWith *string `json:"id_starts_with,omitempty"`
IDNotStartsWith *string `json:"id_not_starts_with,omitempty"`
IDEndsWith *string `json:"id_ends_with,omitempty"`
IDNotEndsWith *string `json:"id_not_ends_with,omitempty"`
NickName *string `json:"nickName,omitempty"`
NickNameNot *string `json:"nickName_not,omitempty"`
NickNameIn []string `json:"nickName_in,omitempty"`
NickNameNotIn []string `json:"nickName_not_in,omitempty"`
NickNameLt *string `json:"nickName_lt,omitempty"`
NickNameLte *string `json:"nickName_lte,omitempty"`
NickNameGt *string `json:"nickName_gt,omitempty"`
NickNameGte *string `json:"nickName_gte,omitempty"`
NickNameContains *string `json:"nickName_contains,omitempty"`
NickNameNotContains *string `json:"nickName_not_contains,omitempty"`
NickNameStartsWith *string `json:"nickName_starts_with,omitempty"`
NickNameNotStartsWith *string `json:"nickName_not_starts_with,omitempty"`
NickNameEndsWith *string `json:"nickName_ends_with,omitempty"`
NickNameNotEndsWith *string `json:"nickName_not_ends_with,omitempty"`
Password *string `json:"password,omitempty"`
PasswordNot *string `json:"password_not,omitempty"`
PasswordIn []string `json:"password_in,omitempty"`
PasswordNotIn []string `json:"password_not_in,omitempty"`
PasswordLt *string `json:"password_lt,omitempty"`
PasswordLte *string `json:"password_lte,omitempty"`
PasswordGt *string `json:"password_gt,omitempty"`
PasswordGte *string `json:"password_gte,omitempty"`
PasswordContains *string `json:"password_contains,omitempty"`
PasswordNotContains *string `json:"password_not_contains,omitempty"`
PasswordStartsWith *string `json:"password_starts_with,omitempty"`
PasswordNotStartsWith *string `json:"password_not_starts_with,omitempty"`
PasswordEndsWith *string `json:"password_ends_with,omitempty"`
PasswordNotEndsWith *string `json:"password_not_ends_with,omitempty"`
LoginAt *string `json:"loginAt,omitempty"`
LoginAtNot *string `json:"loginAt_not,omitempty"`
LoginAtIn []string `json:"loginAt_in,omitempty"`
LoginAtNotIn []string `json:"loginAt_not_in,omitempty"`
LoginAtLt *string `json:"loginAt_lt,omitempty"`
LoginAtLte *string `json:"loginAt_lte,omitempty"`
LoginAtGt *string `json:"loginAt_gt,omitempty"`
LoginAtGte *string `json:"loginAt_gte,omitempty"`
IsInGame *bool `json:"isInGame,omitempty"`
IsInGameNot *bool `json:"isInGame_not,omitempty"`
Token *string `json:"token,omitempty"`
TokenNot *string `json:"token_not,omitempty"`
TokenIn []string `json:"token_in,omitempty"`
TokenNotIn []string `json:"token_not_in,omitempty"`
TokenLt *string `json:"token_lt,omitempty"`
TokenLte *string `json:"token_lte,omitempty"`
TokenGt *string `json:"token_gt,omitempty"`
TokenGte *string `json:"token_gte,omitempty"`
TokenContains *string `json:"token_contains,omitempty"`
TokenNotContains *string `json:"token_not_contains,omitempty"`
TokenStartsWith *string `json:"token_starts_with,omitempty"`
TokenNotStartsWith *string `json:"token_not_starts_with,omitempty"`
TokenEndsWith *string `json:"token_ends_with,omitempty"`
TokenNotEndsWith *string `json:"token_not_ends_with,omitempty"`
And []UserScalarWhereInput `json:"AND,omitempty"`
Or []UserScalarWhereInput `json:"OR,omitempty"`
Not []UserScalarWhereInput `json:"NOT,omitempty"`
          }

      type RoomCreateInput struct {
        ID *string `json:"id,omitempty"`
RoomNickName *string `json:"roomNickName,omitempty"`
Players *UserCreateManyWithoutRoomInput `json:"players,omitempty"`
          }

      type RoomSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *RoomWhereInput `json:"node,omitempty"`
And []RoomSubscriptionWhereInput `json:"AND,omitempty"`
Or []RoomSubscriptionWhereInput `json:"OR,omitempty"`
Not []RoomSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type UserCreateManyWithoutRoomInput struct {
        Create []UserCreateWithoutRoomInput `json:"create,omitempty"`
Connect []UserWhereUniqueInput `json:"connect,omitempty"`
          }

      type RoomUpsertWithoutPlayersInput struct {
        Update RoomUpdateWithoutPlayersDataInput `json:"update"`
Create RoomCreateWithoutPlayersInput `json:"create"`
          }

      type UserCreateWithoutRoomInput struct {
        ID *string `json:"id,omitempty"`
NickName string `json:"nickName"`
Password *string `json:"password,omitempty"`
LoginAt *string `json:"loginAt,omitempty"`
IsInGame *bool `json:"isInGame,omitempty"`
Token *string `json:"token,omitempty"`
          }

      type UserWhereUniqueInput struct {
        ID *string `json:"id,omitempty"`
NickName *string `json:"nickName,omitempty"`
          }

      type RoomUpdateInput struct {
        RoomNickName *string `json:"roomNickName,omitempty"`
Players *UserUpdateManyWithoutRoomInput `json:"players,omitempty"`
          }

      type UserUpdateInput struct {
        NickName *string `json:"nickName,omitempty"`
Password *string `json:"password,omitempty"`
LoginAt *string `json:"loginAt,omitempty"`
IsInGame *bool `json:"isInGame,omitempty"`
Token *string `json:"token,omitempty"`
Room *RoomUpdateOneWithoutPlayersInput `json:"room,omitempty"`
          }

      type RoomCreateOneWithoutPlayersInput struct {
        Create *RoomCreateWithoutPlayersInput `json:"create,omitempty"`
Connect *RoomWhereUniqueInput `json:"connect,omitempty"`
          }

      type UserSubscriptionWhereInput struct {
        MutationIn []MutationType `json:"mutation_in,omitempty"`
UpdatedFieldsContains *string `json:"updatedFields_contains,omitempty"`
UpdatedFieldsContainsEvery []string `json:"updatedFields_contains_every,omitempty"`
UpdatedFieldsContainsSome []string `json:"updatedFields_contains_some,omitempty"`
Node *UserWhereInput `json:"node,omitempty"`
And []UserSubscriptionWhereInput `json:"AND,omitempty"`
Or []UserSubscriptionWhereInput `json:"OR,omitempty"`
Not []UserSubscriptionWhereInput `json:"NOT,omitempty"`
          }

      type UserUpdateManyDataInput struct {
        NickName *string `json:"nickName,omitempty"`
Password *string `json:"password,omitempty"`
LoginAt *string `json:"loginAt,omitempty"`
IsInGame *bool `json:"isInGame,omitempty"`
Token *string `json:"token,omitempty"`
          }

      type RoomUpdateManyMutationInput struct {
        RoomNickName *string `json:"roomNickName,omitempty"`
          }

      type UserCreateInput struct {
        ID *string `json:"id,omitempty"`
NickName string `json:"nickName"`
Password *string `json:"password,omitempty"`
LoginAt *string `json:"loginAt,omitempty"`
IsInGame *bool `json:"isInGame,omitempty"`
Token *string `json:"token,omitempty"`
Room *RoomCreateOneWithoutPlayersInput `json:"room,omitempty"`
          }

      type UserUpdateWithWhereUniqueWithoutRoomInput struct {
        Where UserWhereUniqueInput `json:"where"`
Data UserUpdateWithoutRoomDataInput `json:"data"`
          }

      type UserUpdateManyMutationInput struct {
        NickName *string `json:"nickName,omitempty"`
Password *string `json:"password,omitempty"`
LoginAt *string `json:"loginAt,omitempty"`
IsInGame *bool `json:"isInGame,omitempty"`
Token *string `json:"token,omitempty"`
          }

      type RoomCreateWithoutPlayersInput struct {
        ID *string `json:"id,omitempty"`
RoomNickName *string `json:"roomNickName,omitempty"`
          }

      type RoomUpdateOneWithoutPlayersInput struct {
        Create *RoomCreateWithoutPlayersInput `json:"create,omitempty"`
Update *RoomUpdateWithoutPlayersDataInput `json:"update,omitempty"`
Upsert *RoomUpsertWithoutPlayersInput `json:"upsert,omitempty"`
Delete *bool `json:"delete,omitempty"`
Disconnect *bool `json:"disconnect,omitempty"`
Connect *RoomWhereUniqueInput `json:"connect,omitempty"`
          }

      type RoomUpdateWithoutPlayersDataInput struct {
        RoomNickName *string `json:"roomNickName,omitempty"`
          }


        type UserPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
            var v UserPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
            var v []UserPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type UserPreviousValues struct {
          ID string `json:"id"`
NickName string `json:"nickName"`
Password *string `json:"password,omitempty"`
LoginAt *string `json:"loginAt,omitempty"`
IsInGame bool `json:"isInGame"`
Token *string `json:"token,omitempty"`
        }


        type UserExec struct {
          exec *prisma.Exec
        }

        
                func (instance *UserExec) Room() *RoomExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Room"},
                    "room",
                    []string{"id","createdAt","roomNickName"})

                  return &RoomExec{ret}
                }

          func (instance UserExec) Exec(ctx context.Context) (*User, error) {
            var v User
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance UserExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
            var v []User
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type User struct {
          ID string `json:"id"`
NickName string `json:"nickName"`
Password *string `json:"password,omitempty"`
LoginAt *string `json:"loginAt,omitempty"`
IsInGame bool `json:"isInGame"`
Token *string `json:"token,omitempty"`
        }

        type RoomEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *RoomEdgeExec) Node() *RoomExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Room"},
                    "node",
                    []string{"id","createdAt","roomNickName"})

                  return &RoomExec{ret}
                }

          func (instance RoomEdgeExec) Exec(ctx context.Context) (*RoomEdge, error) {
            var v RoomEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance RoomEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type RoomEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance RoomEdgeExecArray) Exec(ctx context.Context) ([]RoomEdge, error) {
            var v []RoomEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type RoomEdge struct {
          Node Room `json:"node"`
Cursor string `json:"cursor"`
        }


        type RoomExec struct {
          exec *prisma.Exec
        }

        
                type PlayersParamsExec struct {
                  Where *UserWhereInput
OrderBy *UserOrderByInput
Skip *int32
After *string
Before *string
First *int32
Last *int32
                }
                func (instance *RoomExec) Players(params *PlayersParamsExec) *UserExecArray {
                  var wparams *prisma.WhereParams
                  if params != nil {
                    wparams = &prisma.WhereParams{
                      Where: params.Where,
                      OrderBy: (*string)(params.OrderBy),
                      Skip: params.Skip,
                      After: params.After,
                      Before: params.Before,
                      First: params.First,
                      Last: params.Last,
                    }
                  }

                  ret := instance.exec.Client.GetMany(
                    instance.exec,
                    wparams,
                    [3]string{"UserWhereInput", "UserOrderByInput", "User"},
                    "players",
                    []string{"id","nickName","password","loginAt","isInGame","token"})

                  return &UserExecArray{ret}
                }

          func (instance RoomExec) Exec(ctx context.Context) (*Room, error) {
            var v Room
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance RoomExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type RoomExecArray struct {
            exec *prisma.Exec
          }

          func (instance RoomExecArray) Exec(ctx context.Context) ([]Room, error) {
            var v []Room
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type Room struct {
          ID string `json:"id"`
CreatedAt string `json:"createdAt"`
RoomNickName *string `json:"roomNickName,omitempty"`
        }

        type RoomConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *RoomConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                  func (instance *RoomConnectionExec) Edges() *RoomEdgeExecArray {
                    edges := instance.exec.Client.GetMany(
                      instance.exec,
                      nil,
                      [3]string{"RoomWhereInput", "RoomOrderByInput", "RoomEdge"},
                      "edges",
                      []string{"cursor"})

                    nodes := edges.Client.GetMany(
                      edges,
                      nil,
                      [3]string{"", "", "Room"},
                      "node",
                      []string{"id", "createdAt", "updatedAt", "name", "desc"})

                    return &RoomEdgeExecArray{nodes}
                  }

                  func (instance *RoomConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateRoom"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return &v, err
                  }

          func (instance RoomConnectionExec) Exec(ctx context.Context) (*RoomConnection, error) {
            var v RoomConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance RoomConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type RoomConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance RoomConnectionExecArray) Exec(ctx context.Context) ([]RoomConnection, error) {
            var v []RoomConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type RoomConnection struct {
          PageInfo PageInfo `json:"pageInfo"`
Edges []RoomEdge `json:"edges"`
        }

        type RoomSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *RoomSubscriptionPayloadExec) Node() *RoomExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "Room"},
                    "node",
                    []string{"id","createdAt","roomNickName"})

                  return &RoomExec{ret}
                }

                func (instance *RoomSubscriptionPayloadExec) PreviousValues() *RoomPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "RoomPreviousValues"},
                    "previousValues",
                    []string{"id","createdAt","roomNickName"})

                  return &RoomPreviousValuesExec{ret}
                }

          func (instance RoomSubscriptionPayloadExec) Exec(ctx context.Context) (*RoomSubscriptionPayload, error) {
            var v RoomSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance RoomSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type RoomSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance RoomSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]RoomSubscriptionPayload, error) {
            var v []RoomSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type RoomSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
Node *Room `json:"node,omitempty"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type RoomPreviousValuesExec struct {
          exec *prisma.Exec
        }

        

          func (instance RoomPreviousValuesExec) Exec(ctx context.Context) (*RoomPreviousValues, error) {
            var v RoomPreviousValues
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance RoomPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type RoomPreviousValuesExecArray struct {
            exec *prisma.Exec
          }

          func (instance RoomPreviousValuesExecArray) Exec(ctx context.Context) ([]RoomPreviousValues, error) {
            var v []RoomPreviousValues
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type RoomPreviousValues struct {
          ID string `json:"id"`
CreatedAt string `json:"createdAt"`
RoomNickName *string `json:"roomNickName,omitempty"`
        }

        type UserSubscriptionPayloadExec struct {
          exec *prisma.Exec
        }

        
                func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "node",
                    []string{"id","nickName","password","loginAt","isInGame","token"})

                  return &UserExec{ret}
                }

                func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "UserPreviousValues"},
                    "previousValues",
                    []string{"id","nickName","password","loginAt","isInGame","token"})

                  return &UserPreviousValuesExec{ret}
                }

          func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
            var v UserSubscriptionPayload
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserSubscriptionPayloadExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
            var v []UserSubscriptionPayload
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type UserSubscriptionPayload struct {
          Mutation MutationType `json:"mutation"`
Node *User `json:"node,omitempty"`
UpdatedFields []string `json:"updatedFields,omitempty"`
        }

        type UserConnectionExec struct {
          exec *prisma.Exec
        }

        
                func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "PageInfo"},
                    "pageInfo",
                    []string{"hasNextPage","hasPreviousPage","startCursor","endCursor"})

                  return &PageInfoExec{ret}
                }

                  func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
                    edges := instance.exec.Client.GetMany(
                      instance.exec,
                      nil,
                      [3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
                      "edges",
                      []string{"cursor"})

                    nodes := edges.Client.GetMany(
                      edges,
                      nil,
                      [3]string{"", "", "User"},
                      "node",
                      []string{"id", "createdAt", "updatedAt", "name", "desc"})

                    return &UserEdgeExecArray{nodes}
                  }

                  func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
                    ret := instance.exec.Client.GetOne(
                      instance.exec,
                      nil,
                      [2]string{"", "AggregateUser"},
                      "aggregate",
                      []string{"count"})

                    var v Aggregate
                    _, err := ret.Exec(ctx, &v)
                    return &v, err
                  }

          func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
            var v UserConnection
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserConnectionExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
            var v []UserConnection
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type UserConnection struct {
          PageInfo PageInfo `json:"pageInfo"`
Edges []UserEdge `json:"edges"`
        }

        type UserEdgeExec struct {
          exec *prisma.Exec
        }

        
                func (instance *UserEdgeExec) Node() *UserExec {
                  ret := instance.exec.Client.GetOne(
                    instance.exec,
                    nil,
                    [2]string{"", "User"},
                    "node",
                    []string{"id","nickName","password","loginAt","isInGame","token"})

                  return &UserExec{ret}
                }

          func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
            var v UserEdge
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type UserEdgeExecArray struct {
            exec *prisma.Exec
          }

          func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
            var v []UserEdge
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type UserEdge struct {
          Node User `json:"node"`
Cursor string `json:"cursor"`
        }


        type PageInfoExec struct {
          exec *prisma.Exec
        }

        

          func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
            var v PageInfo
            ok, err := instance.exec.Exec(ctx, &v)
            if err != nil {
              return nil, err
            }
            if !ok {
              return nil, ErrNoResult
            }
            return &v, nil
          }

          func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
            return instance.exec.Exists(ctx)
          }

          type PageInfoExecArray struct {
            exec *prisma.Exec
          }

          func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
            var v []PageInfo
            err := instance.exec.ExecArray(ctx, &v)
            return v, err
          }

        type PageInfo struct {
          HasNextPage bool `json:"hasNextPage"`
HasPreviousPage bool `json:"hasPreviousPage"`
StartCursor *string `json:"startCursor,omitempty"`
EndCursor *string `json:"endCursor,omitempty"`
        }






        